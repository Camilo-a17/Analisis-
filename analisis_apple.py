# -*- coding: utf-8 -*-
"""Analisis Apple.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1yytLalm21MXdsh_dKpy7NpyXE0Rcc1zU
"""

import pandas as pd
import numpy as np
import plotly.express as px
import plotly.graph_objects as go
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_absolute_error
from sklearn.impute import SimpleImputer

# Importamos el dataset
df = pd.read_csv("aapl_raw_data.csv")

df.describe()

print(df.columns)

# Convertimos la fecha a un tipo de datos de fecha
df['date'] = pd.to_datetime(df['date'])

# Creamos un gráfico de línea para los precios de cierre
fig = px.line(df, x='date', y='close')

# Mostramos el gráfico
fig.show()

# Calculamos la desviación estándar de los cambios porcentuales
std = df['change_percent'].std()

# Imprimimos la desviación estándar
print(std)

# Seleccionar características y objetivo
features = ['open', 'high', 'low', 'volume', 'adjusted_close', 'change_percent', 'avg_vol_20d']
target = 'close'

X = df[features]
y = df[target]

# Tratar los valores faltantes con un imputador
imputer = SimpleImputer(strategy='mean')
X_imputed = imputer.fit_transform(X)

# Dividir los datos en conjuntos de entrenamiento y prueba
X_train, X_test, y_train, y_test = train_test_split(X_imputed, y, test_size=0.25, random_state=42)

# Crear y entrenar el modelo de regresión lineal
model = LinearRegression()
model.fit(X_train, y_train)

# Realizar predicciones en el conjunto de prueba
y_pred = model.predict(X_test)

# Evaluar el modelo
mae = mean_absolute_error(y_test, y_pred)
print(f"Mean Absolute Error: {mae}")

# Crear un DataFrame con los resultados
results_df = pd.DataFrame({'Actual': y_test, 'Predicted': y_pred})

# Crear una figura interactiva con Plotly
fig = px.scatter(results_df, x='Actual', y='Predicted', title='Actual vs. Predicted Prices')
fig.update_layout(xaxis_title='Actual Price', yaxis_title='Predicted Price')
fig.show()

# Seleccionar características y objetivo
features = ['open', 'high', 'low', 'volume', 'adjusted_close', 'change_percent', 'avg_vol_20d']
target = 'close'

X = df[features]
y = df[target]

# Tratar los valores faltantes con un imputador
imputer = SimpleImputer(strategy='mean')
X_imputed = imputer.fit_transform(X)

# Dividir los datos en conjuntos de entrenamiento y prueba
X_train, X_test, y_train, y_test = train_test_split(X_imputed, y, test_size=0.25, random_state=42)

# Crear y entrenar el modelo de regresión lineal
model = LinearRegression()
model.fit(X_train, y_train)

# Realizar predicciones en el conjunto de prueba
y_pred = model.predict(X_test)

# Crear un DataFrame con los resultados
results_df = pd.DataFrame({'Actual': y_test, 'Predicted': y_pred})

# Agregar las fechas correspondientes a los futuros precios predichos
future_dates = df['date'].iloc[X_train.shape[0]:]  # Las fechas de los datos de prueba
results_df['Date'] = future_dates

# Crear el gráfico en 3D
fig = go.Figure(data=[go.Scatter3d(
    x=results_df['Date'],
    y=results_df['Actual'],
    z=results_df['Predicted'],
    mode='markers',
    marker=dict(size=5, color='blue'),
    text=results_df['Date']
)])

# Personalizar el diseño del gráfico
fig.update_layout(scene=dict(xaxis_title='Date', yaxis_title='Actual Price', zaxis_title='Predicted Price'),
                  title='Actual vs. Predicted Prices in 3D')
fig.show()

# Seleccionar características y objetivo
features = ['open', 'high', 'low', 'volume', 'adjusted_close', 'change_percent', 'avg_vol_20d']
target = 'close'

X = df[features]
y = df[target]

# Tratar los valores faltantes con un imputador
imputer = SimpleImputer(strategy='mean')
X_imputed = imputer.fit_transform(X)

# Dividir los datos en conjuntos de entrenamiento y prueba
X_train, X_test, y_train, y_test = train_test_split(X_imputed, y, test_size=0.25, random_state=42)

# Crear y entrenar el modelo de regresión lineal
model = LinearRegression()
model.fit(X_train, y_train)

# Realizar predicciones en el conjunto de prueba
y_pred = model.predict(X_test)

# Evaluar el modelo
mae = mean_absolute_error(y_test, y_pred)
print(f"Mean Absolute Error: {mae}")

# Crear un DataFrame con los resultados
results_df = pd.DataFrame({'Actual': y_test, 'Predicted': y_pred})

# Agregar las fechas correspondientes a los futuros precios predichos
future_dates = df['date'].iloc[X_train.shape[0]:]  # Las fechas de los datos de prueba
results_df['Date'] = future_dates

# Crear un gráfico interactivo con Plotly
fig = px.line(results_df, x='Date', y=['Actual', 'Predicted'], title='Actual vs. Predicted Prices of Closing')
fig.update_layout(xaxis_title='Date', yaxis_title='Price', legend_title='Prices')
fig.show()